# -*- coding: utf-8 -*-
"""K_means_Q2_ii.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1-5m0uExjB1Gzq08AO97hAV289QbJCY0h
"""

import numpy as np
import seaborn as sns
import matplotlib.pyplot as plt
from scipy.linalg import eigh
import pandas as pd
from scipy.spatial import Voronoi, voronoi_plot_2d, KDTree

dataset = pd.read_csv("Dataset.csv", names=['p','q'])
X_dataset=dataset.to_numpy()

def k_means(data,k=4,iterations=200,se=12):


  error=[]
  np.random.seed(se)
  assignment_array,clusters=random_cluster_assignment(data,k,)
  initial_cluster_means=calculate_cluster_means(clusters)
  error.append(compute_error(clusters,initial_cluster_means))
  prev_assignment= np.array(assignment_array)
  
  for i in range(iterations):
    #print(i)
    next_assignment=[]
    for k in range(len(data)):
      # prev_assignment= np.array(data_and_index)[:,1]
      closest_cluster_idx=closest_cluster(data[k],initial_cluster_means)
      next_assignment.append(closest_cluster_idx)
      updated_clusters=update_clusters_with_data_pt(data[k],closest_cluster_idx,clusters,prev_assignment[k])

      #datapoints[1]=closest_cluster_idx
    
    
    new_cluster_means=calculate_cluster_means(updated_clusters)
    initial_cluster_means=new_cluster_means
    error.append(compute_error(updated_clusters,initial_cluster_means))
    clusters=updated_clusters.copy()
    if np.sum(np.squeeze(prev_assignment) - np.squeeze(np.array(next_assignment))) !=0:
      prev_assignment= np.array(next_assignment)
      continue
    else:
      last_iter=i
      print("Last Iteration =",i)
      break
    

  #plt.figure(i)
  #plt.scatter(data_and_index[:,0][0], data[:,1], c=model.labels_.astype(float))
  return np.array(next_assignment),error,last_iter,new_cluster_means

def update_clusters_with_data_pt(Data_point,assigned_cluster, clusters,prev_assigned_cluster=0):
  #print(prev_assigned_cluster)
  if prev_assigned_cluster==0:
    clusters[assigned_cluster].append(Data_point)

  else:
    C=[]
    for i,data_point in enumerate(clusters[prev_assigned_cluster]):
    # clusters[prev_assigned_cluster].pop(Data_point)
      if (data_point[0] != Data_point[0]) and  (data_point[1] != Data_point[1]):
        C.append(data_point)
    clusters[prev_assigned_cluster]=C
    clusters[assigned_cluster].append(Data_point)
  return clusters

def random_cluster_assignment(input_data,n_clusters=4):
  assignment_array=np.random.randint(1,n_clusters+1,len(input_data))

  clusters={}
  for i in range(1,n_clusters+1):
    clusters[i]=[]
  
  for i in range(len(input_data)):
    clusters=update_clusters_with_data_pt(input_data[i],assignment_array[i], clusters,prev_assigned_cluster=0)

  return np.array(assignment_array),clusters

def calculate_cluster_means(clusters):
  means=[]
  for i in clusters.keys():
    if len(clusters[i])!=0:
      m=np.mean(clusters[i],axis=0)
    else:
      m=np.array([0,0])
    means.append(m)
  return np.array(means)

def compute_error(clusters,means):#0,1,2,3
  err=0
  means=calculate_cluster_means(clusters)
  for i in range(len(means)):###############################modification
    if len(clusters[i+1]) !=0:
      err_cluster_i=np.sum((np.array(clusters[i+1]) - np.array(means[i]))**2)
    else:
      err_cluster_i=0
    err+=err_cluster_i
  return err

def closest_cluster(data_pt,means):
  #a=np.argmin(np.sum(np.array(np.array(data_pt) - np.array(means))**2, axis=1))
  a=[]
  for mean in means:
    a.append(np.sum((np.array(data_pt) - np.array(mean))**2))

  i=np.argmin(np.array(a))
  return i+1 #cluster index

def Plot_Clusters_and_Voronoi_regions(X_dataset):  
  for num_clusters in range(2,6): 
    k_assignment,err,last_iter,means=k_means(X_dataset,num_clusters)
  
    fig = plt.figure(figsize=(8,6))

    plt.scatter(X_dataset[:,0],X_dataset[:,1],c=k_assignment)
    plt.scatter(means[:,0],means[:,1],marker="X",color="black",s=90)
    print(means)

    if num_clusters == 2 :
        from sympy import Point, Segment, Line
        s1 = Segment(Point(means[0][0], means[0][1]), Point(means[1][0], means[1][1]))
        bisector = s1.perpendicular_bisector()

        p1 = bisector.intersection(Line(Point(-10,0), Point(-10, 10)))[0]
        p2 = bisector.intersection(Line(Point(10,0), Point(10, 10)))[0]
    
        plt.plot(np.array([p1.coordinates[0], p2.coordinates[0]]), np.array([p1.coordinates[1], p2.coordinates[1]]), c='black', ls='--', lw=1)
    else:
      vor = Voronoi(means)
      fig = voronoi_plot_2d(vor,plt.gca())

    plt.xlim([np.min(X_dataset[:,0]) - 1, np.max(X_dataset[:,0]) + 1])
    plt.ylim([np.min(X_dataset[:,1]) - 1, np.max(X_dataset[:,1]) + 1])
    plt.title("K-means clustering using "+str(num_clusters)+" clusters.")
    plt.show()
    print("\n ============================================================================================")

Plot_Clusters_and_Voronoi_regions(X_dataset)